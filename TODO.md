todo:
* 完善单元测试 [doing]
* 完善错误处理
* block的crc校验和lru cache策略，是上条的基础 [done]
* 记录统计信息和日志
* 提供迭代器 [delete]
* 重构page磁盘管理 （目前的这种位图形式还是不太行，消耗空间太大）[done]
* 处理字节序问题
* block的dirty机制，减少不必要的刷盘操作 [done]
* cache希望block的析构函数中进行资源释放（调用manager进行刷盘），但是需要在析构函数中调用虚函数，因此需要修改cache，提供destructor前注册机制 [done]
* cache目前的实现有bug，Block生命周期管理不明确，需要修改接口 [done]

// 这两点需要放在最后完成
* 基于WAL的崩溃恢复机制
* b+树并发控制

### 关于并发控制
参考这篇文章：https://zhuanlan.zhihu.com/p/50112182
总结如下：
在多线程同时访问b+树时，我们希望满足以下几点要求：
多个读操作可以并发进行；
每个读操作不会读到任何写操作的中间状态（例如正在执行分裂操作的页、由于分裂导致的索引和数据不一致的状态等）；
读操作不会找不到存在的数据；
两个写操作不会同时修改同一个键值对；
没有死锁情况出现；

#### 版本一 基础并发控制机制（MySQL5.6）
这个版本的mysql采用了两种粒度的锁：整棵树粒度的读写锁，以及页粒度的读写锁。
读：
* 对整棵树加读锁；
* 从根节点开始，找到数据所在的页，并对该页加读锁；
* 释放整棵树上的锁；
* 访问数据，释放页上的锁；

悲观写：
* 对整棵树加写锁；
* 从根节点开始，找到数据所在的页，并对该页加写锁；
* 判断修改操作是否会导致该页产生split/merge等操作，如果是，则执行split/merge等操作，然后释放树上的锁，然后在页上执行修改操作，最后释放页上的写锁；如果不是则直接在页上进行修改操作，并释放锁即可；

乐观写：
* 对整颗树加读锁：
* 从根节点开始，找到数据所在的页，并对该页加写锁；
* 判断修改操作是否会导致该页产生split/merge等操作，如果是，则本次乐观写失败，释放所有锁并返回，重新执行悲观写；如果不是，则进行修改，释放锁并返回；

相比于悲观写，乐观写在大部分不触发split/merge等操作的情况下，对非数据页的节点持有读锁，只对数据页节点持有写锁，因此不阻塞其他的读和不在同一个数据页上的写操作。并且对于死锁问题，只要加锁顺序保证一致即可避免（从上到下，从左到右）。

#### 版本二 1976年，论文《B-trees in a system with multiple users》
论文中提出了一种新的方案，如下
读：
* 首先持有根节点的读锁；
* 在父节点中找到子节点，对子节点加读锁，然后释放父节点的读锁，重复这一过程到数据页节点；
* 访问数据后释放数据页上的读锁，返回。

和第一个版本相比，这个版本放弃使用整棵树级别的读锁，替换为页级别的读锁。

写：
* 首先持有根节点的写锁：
* 在父节点中找到子节点，对子节点加写锁，然后判断父节点是不是安全节点（即在子节点发生split/merge的情况下是否会导致自己产生split/merge），如果是，则释放父节点的锁，否则需要保持父节点的锁，重复这一过程到数据页节点；
* 此时已经持有了最坏情况下所有可能需要数据修改的页节点的写锁，修改数据并原路返回，释放加的锁即可。

这个版本的写操作依然是悲观的，在不确定页节点是否会被修改时加了写锁。

#### 版本三 1977年，《Concurrency of operations on B -trees》论文

论文中提出了SX锁的概念，SX锁也被使用到了Mysql5.7中。此外，第一个版本的乐观写也是在本文中提出的。
首先说明下SX锁的概念：SX锁阻塞其他的SX、X加锁操作，但允许S加锁操作，并且它可以在加SX锁成功时执行升级功能，阻塞其他S、X、SX操作。

使用SX锁的写算法，只需要在上述第二个版本的写算法中，将第二步的写锁换成SX锁，这样在写操作影响的分支上的锁升级为写锁之前，其他的读操作都可以访问加了SX锁的分支，从而减少了线程之间的冲突。

在多核处理器上频繁加锁会导致每个核心的private cache频繁失效，而核间保证缓存一致性的协议开销是很大的（见这里：https://zhuanlan.zhihu.com/p/84500221）
之后文章中给出了blink树和OLFIT树两种实现，但是个人认为这两种实现的启发意义大于实际意义，原因如下：1. 假设读写树节点的操作是原子性的（就我的知识水平来看，还是会导致多核在某一个变量上频繁修改、判断，问题还是存在）；2. 删除操作处理麻烦，需要锁住整个b+树。
这里跳过这部分内容的详述。

#### Mysql5.7的b+树并发控制机制
读操作采用上述第二个版本的读即可；
写操作采用乐观写（如果失败则悲观写）的策略，乐观写只需要将版本二中读操作中对数据页加读锁变成加写锁即可；悲观写采用版本三中的基于SX锁的写操作即可。


### 本项目并发控制策略的选择
选择Mysql5.7的b+树并发控制策略，目前的问题是需要实现SX锁。

