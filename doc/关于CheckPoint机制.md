### checkpoint基本概念
为了防止wal日志无限增长导致的存储空间消耗过大，恢复时间过长的问题，引入了checkpoint机制：系统每隔一段时间将缓存中的所有脏页刷盘，刷盘后
之前的所有日志均不需要保存，因此可以重复利用存储空间。恢复时只需要从最后一次成功checkpoint的地方开始重放wal日志即可。

#### 本项目中的处理
* 本项目并不会显式的插入checkpoint日志，而是进行周期性的wal日志清空操作，在清空之前刷新所有脏页到磁盘即可，这种方式简化了check point机制的实现。
注意：每次生成check point的操作会阻塞所有操作（因为wal日志此刻不应该再被写入），因此如果脏页的数量过多，会导致较长的阻塞，这对于使用者来说
是不好的。本项目通过以下机制缓解这一阻塞时间：每隔固定数量的操作执行完成后，本项目进行一次部分脏页刷盘操作：如果cache中的脏页比例达到一定程度(%75)，
则按照lru链表逆序将部分block刷回磁盘，这样相当于均摊了脏页刷盘的开销。
由于支持事务机制的实现太过复杂，本项目目前仅提供单个操作的原子性和持久性保证，这大大简化了设计和实现。

* 注：对于实现事务机制而言，以上实现是有问题的，原因如下：
1. 在生成checkpoint的地方可能有未完成的事务，不能将日志全部清空。
2. 一个事务的wal日志可以安全删除的前提是：其所修改的所有block都成功刷盘。
因此，生成checkpoint时需要保留部分日志（由以上两个条件共同决定），这对于设计实现wal日志空间的重用而言，过于复杂。

支持事务机制的设计如下：每一条wal日式有一个编号，每个block的元数据同样记录一个编号，该编号的含义是最后一个在block上修改数据的操作对应的wal日志编号。
wal日志存储在两个地方：wal磁盘日志以及wal内存buffer，定期将内存buffer中的日志批量刷到磁盘中并进行fsync同步。
有以下几个基本原则是必须保证的：
1. 内存中的block刷盘前，对应的所有修改操作的wal日志必须已经落盘。原因：否则如果在block刷盘后，wal日志落盘前机器crash并重启恢复，部分操作已经在block上修改但是没有对应的wal日志进行redo和undo，数据
一致性无法保证。
2. 当block从磁盘加载到内存后，对其进行第一次修改操作对应的wal日志编号记录为BLOCK-NUM，当前内存中的block对应的BLOCK-NUM组成一集合，集合中的最小值BLOCK-MIN-NUM及其之后的日志不能被删除，原因：
修改操作仅仅在内存中的block进行，还没有落盘，因此需要这些wal日志进行redo和undo保证数据一致性。
3. 在生成check point时，没完成的所有事务的事务开始日志对应的编号作为一个集合，该集合中的最小值记录为MIN-TX-NUM，MIN-TX-NUM对应的wal日志及其之后的日志是不能被清理的。原因：
保证事务的原子性，这些日志不能删除，防止这时机器crash并重启恢复时，无法回滚事务。

也就是说，只有事务已经提交或者回滚（即对应的wal日志落盘），并且该事务所涉及的所有block都刷盘后，这个事务的日志才能被安全删除。两个条件中有一个不满足（分别对应了情况2和情况3），则不能删除。